#### **Summary**
- เป็นขั้นตอนสุดท้ายของการ Design Database 
- แปลงจาก Logical Design ให้มี การดำเนินการที่มีประสิทธิภาพ (an efficient implementation)
- มุ่งเน้นไปที่ประสิทธิภาพการทำงานของ Database
#### **Defination**
- Process of producing a description of the implementation of the database on secondary storage 
- Describe: 
	- Base relations (derived data, general constraints) (ความสัมพันธ์ระหว่างข้อมูลและข้อกำหนดของข้อมูล)
	- File organization (การจัดการไฟล์)
	- Indexes 
	- Query optimization (ประสิทธิภาพการเข้าถึง)
	- Security measures (ความปลอดภัยของข้อมูล)
#### Derived data
- เป็น Attribute ที่เกิดมาจากการคำนวณของ Attribute อื่น ๆ
- Ex. จำนวนพนักงานทั้งหมดในสาขานั้น ๆ
- มีอยู่สองตัวเลือกในการเก็บ Derived Data คือ
	- Store (เก็บค้างไว้เป็น Attribute หนึ่งไปเลย)
		- ทำให้เปลืองพื้นที่จัดเก็บ , ข้อมูลอาจจะเก่า
		- เหมาะกับการสรุปยอดราคาในบิล
		- มีประสิทธิภาพมากกว่าการคำนวณใหม่ทุกครั้ง
	- Calculate (คำนวณใหม่ทุกครั้งที่ต้องการใช้)
		- ข้อมูลทันสมัยกว่า (Up to date)
		- มีประสิทธิภาพน้อยกว่าแบบ Store
		- ประหยัดพื้นที่จัดเก็บได้
#### General constraints
- มีรูปแบบที่เห็นได้ทั่วไปดังนี้
	- Integrity constraint (Primary key)
	- Required data (Not NULL)
	- Check constraint (ใส่เงื่อนไข)
	- Referential constraint (Foreign key)
	- Unique constraint (ห้ามซ้ำ)
- ควรควมคุม constraint ที่ไหน
	- ควรควบคุมที่ Database เพราะโอกาสผิดพลาดน้อย หากไปควมคุมที่ Application จะทำให้เกิดข้อผิดพลาดได้ง่าย เพราะจำเป็นต้องเขียนการควบคุมหลาย ๆ ส่วน

#### File organization
- เป็นสิ่งที่สำคัญมากใน Physical Database Design
- มีวัตถุประสงค์ไปที่การจัดเก็บและเข้าถึงข้อมูลได้อย่างมีประสิทธิภาพ
- ประเภทของ File organization จะขึ้นอยู่กับ DBMS ที่ใช้
- การวิเคราะห์
	- จุคประสงค์ของ Database นั้น ๆ
	- DBMS ที่เลือกใช้
	- ดูที่ Transactions
		- เกิด transactions อะไรบ่อยที่สุด
		- เกิดในช่วงเวลาไหนมากที่สุด
		- สนใจแค่ 20% ที่มีการ Active มากที่สุดแทนการสนใจทั้งหมด
	ยังจดไม่หมดจ้า
#### Index?
- เป็นสิ่งที่ทำให้เราเข้าถึงข้อมูลได้เร็วและมีประสิทธิภาพมากขึ้น
- เปรียบเทียบได้กับ index ในหนังสือ ที่ช่วยให้เราค้นหาสิ่งที่เราสนใจได้เร็วขึ้น (ต่างจากสารบัญตรงที่ว่า index จะเรียงตามตัวอักษรแต่สารบัญจะเรียงตามเนื้อหาในหนังสือ)
- [Index](./Index.md)
#### Denormalization
- ตรงข้ามกับการ Normalization เพราะ
	- การ Normalization ทำให้ต้อง join หลายครั้ง
	- แต่มีข้อดีที่ประหยัดพื้นที่ของข้อมูล
- เราอาจจะเลือกทำ Denormalization ในบางจุดหรือบางตาราง
- ทำเพื่อความเร็วหรือ Performance เป็นหลัก
- ==แลกมากับการเก็บข้อมูลซ้ำซ้อน การเก็บหลาย ๆ ที่==
- การทำ Denormalization
	- ปรับโครงสร้างตารางเดิม
		- การเก็บข้อมูลเพิ่มเพื่อเก็บข้อมูลซ้ำ
	- สร้างตารางใหม่เพิ่ม
		- รวมตารางหลาย ๆ ตารางเข้าด้วยกัน
		- เหมาะกับการสร้างตารางสำหรับการออกรีพอร์ต ( โอกาสที่จะถูกแก้ไขข้อมูลน้อย ) รวมถึงตารางที่เป็นประวัติ
- เกณฑ์ในการเลือกทำ
	- Performance ยังไม่เป็นที่น่าพอใจ
	- ตารางนั้นมีการ Update บ่อยหรือไม่ ถ้าบ่อยก็ไม่เหมาะ
	- ถูก query บ่อยหรือไม่ ถ้าบ่อยก็เหมาะ
- Common situations for denormalization
	- Combining 1:1 relationships
		- ![Pasted image 20240131091800.png](./Pasted%20image%2020240131091800.png)
		- จะมี Trade-off ที่จะมีข้อมูลที่เป็น null อยู่เยอะ
		- กินพื้นที่มาก
	- Duplicating non-key attributes in 1:* relationship to reduce joins
		- เอาคอลัมน์ที่ไม่ใช่ key มาใส่ในอีกตารางด้วย
		- ![Pasted image 20240131092752.png](./Pasted%20image%2020240131092752.png)
		- เวลาอัพเดทจะต้องทำสองที่
		- จะเห็นได้ชัดใน Lookup table หรือ Reference table ( ตารางที่ใช้อ้างอิงตัวย่อ เพื่อการประหยัดพื้นที่ )
		- ก่อนทำ Denormalize![Pasted image 20240131093235.png](./Pasted%20image%2020240131093235.png)
		- หลังทำ Denormalize ![Pasted image 20240131093246.png](./Pasted%20image%2020240131093246.png)
	- Duplicating foreign key attributes in 1:* relationships to reduce joins
		- Before ![Pasted image 20240131093803.png](./Pasted%20image%2020240131093803.png)
		- After ![Pasted image 20240131094003.png](./Pasted%20image%2020240131094003.png)
		- เห็นได้ชัดว่า query ง่ายและเร็วขึ้นมาก
		- ![Pasted image 20240131094044.png](./Pasted%20image%2020240131094044.png)
	- Duplicating attributes in *:* relationships to reduce joins
		- บางครั้งเราอยากรู้แค่บางข้อมูล แต่จำเป็นต้อง join ทั้ง table มาเลยนำมาเก็บไว้อีกตารางด้วย
		- ในกรณีนี้เราเก็บ Street เพิ่ม จะได้ไม่ต้อง join property ตลอด
		- ![Pasted image 20240131094735.png](./Pasted%20image%2020240131094735.png)
	- Introducing repeating groups
		- มีการเก็บข้อมูลซ้ำ ๆ อยู่แล้ว เช่น หนึ่งสาขา มีหลายเบอร์ ถ้าเป็น Normalize ก็ต้องแยกตาราง
		- ![Pasted image 20240131094906.png](./Pasted%20image%2020240131094906.png)
	- Creating extract tables
		- สร้างตารางใหม่ขึ้นมาเพื่อไม่ต้องไป query ตารางเดิมแล้วต้อง join เยอะ ๆ
		- During peak times during the day ( Reports have to run ) จำเป็นต้องทำ Report เพราะมีการ query ข้อมูลเยอะในวัน ๆ เดียวกัน
		- ไม่ควร run script ในช่วงเวลาปกติที่มีการใช้งานเยอะอยู่แล้ว
	- Partitioning relations
		- การแบ่งข้อมูลในตารางออกเป็นชิ้นเล็ก ๆ
		- เช่นสมมุติว่ามีตารางลูกค้าเยอะ ๆ ก็ไม่ควรเก็บไว้ที่เดียวกัน อาจจะแบ่งเป็นภูมิภาค เป็นต้น
		- เพื่อให้การแสกนหาข้อมูลเร็วขึ้น เช่นถ้าเราต้องการค้นหาข้อมูลลูกค้าที่ภาคเหนือ ก็ไม่จำเป็นต้องไปหาที่ภาคใต้ หรือตะวันออกด้วย
		- มีวิธีการทำอยู่หลายแบบ
			- Hash
			- Range
				- แยกข้อมูลเป็นช่วง ๆ
			- List
				- แล้วแต่เราจะ list เป็นอะไร เช่นตามภูมิภาค
		- การแบ่งมีทั้งแบบ
			-  Horizontal partitioning
			- Vertical partitioning
		- Disadvantages 
			- มีความซับซ้อนในการแบ่งของข้อมูล
		- Advantages
			- ทำให้แสกนหาข้อมูลได้เร็วขึ้นตามเงื่อนไขของการแบ่ง